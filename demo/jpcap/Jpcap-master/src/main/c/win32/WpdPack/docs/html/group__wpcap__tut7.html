<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>WinPcap: Handling offline dump files</title>
<link href="style.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>Handling offline dump files</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
In this lession we are going to learn how to handle packet capture to a file (dump to file). WinPcap offers a wide range of functions to save the network traffic to a file and to read the content of dumps -- this lesson will teach how to use all of these functions. We'll see also how to use the kernel dump feature of WinPcap to obtain high-performance dumps (<b>NOTE:</b> At the moment, due to some problems with the new kernel buffer, this feature has been disabled).<p>
The format for dump files is the libpcap one. This format contains the data of the captured packets in binary form and is a standard used by many network tools including WinDump, Ethereal and Snort.<p>
<b>Saving packets to a dump file</b><p>
First of all, let's see how to write packets in libpcap format.<p>
The following example captures the packets from the selected interface and saves them on a file whose name is provided by the user.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "pcap.h"</span>

<span class="comment">/* prototype of the packet handler */</span>
<span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data);

main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
<a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
<a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
<span class="keywordtype">int</span> inum;
<span class="keywordtype">int</span> i=0;
<a class="code" href="group__wpcap__def.html#g4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *adhandle;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#gcd448353957d92c98fccc29e1fc8d927">PCAP_ERRBUF_SIZE</a>];
<a class="code" href="group__wpcap__def.html#gb8c7858aa3a7e3158d9d58cb113a2ae8">pcap_dumper_t</a> *dumpfile;


    
    <span class="comment">/* Check command line */</span>
    <span class="keywordflow">if</span>(argc != 2)
    {
        printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Retrieve the device list on the local machine */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#g98f36e62c95c6ad81eaa8b2bbeb8f16e">pcap_findalldevs_ex</a>(<a class="code" href="group__remote__source__string.html#g6d7103b8a7e1eca8c325bd8f32c361c3">PCAP_SRC_IF_STRING</a>, NULL, &amp;alldevs, errbuf) == -1)
    {
        fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
        exit(1);
    }
    
    <span class="comment">/* Print the list */</span>
    <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#81508e6e4e41ca4235c8d6b51913c536">next</a>)
    {
        printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#5ac083a645d964373f022d03df4849c8">name</a>);
        if (d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>)
            printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>);
        <span class="keywordflow">else</span>
            printf(<span class="stringliteral">" (No description available)\n"</span>);
    }

    <span class="keywordflow">if</span>(i==0)
    {
        printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
    scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
    
    <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
    {
        printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
        
    <span class="comment">/* Jump to the selected adapter */</span>
    <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#81508e6e4e41ca4235c8d6b51913c536">next</a>, i++);
    
    
    <span class="comment">/* Open the device */</span>
    <span class="keywordflow">if</span> ( (adhandle= <a class="code" href="group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791">pcap_open</a>(d-&gt;<a class="code" href="structpcap__if.html#5ac083a645d964373f022d03df4849c8">name</a>,          <span class="comment">// name of the device</span>
                              65536,            <span class="comment">// portion of the packet to capture</span>
                                                <span class="comment">// 65536 guarantees that the whole packet will be captured on all the link layers</span>
                              <a class="code" href="group__remote__open__flags.html#g9134ce51a9a6a7d497c3dee5affdc3b9">PCAP_OPENFLAG_PROMISCUOUS</a>,    <span class="comment">// promiscuous mode</span>
                              1000,             <span class="comment">// read timeout</span>
                              NULL,             <span class="comment">// authentication on the remote machine</span>
                              errbuf            <span class="comment">// error buffer</span>
                              ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#5ac083a645d964373f022d03df4849c8">name</a>);
        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }

    <span class="comment">/* Open the dump file */</span>
    dumpfile = <a class="code" href="group__wpcapfunc.html#g9506c33d580fdb5e5c288dba0f8a085c">pcap_dump_open</a>(adhandle, argv[1]);

    <span class="keywordflow">if</span>(dumpfile==NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nError opening output file\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"\nlistening on %s... Press Ctrl+C to stop...\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>);
    
    <span class="comment">/* At this point, we no longer need the device list. Free it */</span>
    <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);
    
    <span class="comment">/* start the capture */</span>
    <a class="code" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop</a>(adhandle, 0, packet_handler, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)dumpfile);

    <span class="keywordflow">return</span> 0;
}

<span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span>
<span class="keywordtype">void</span> packet_handler(u_char *dumpfile, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    <span class="comment">/* save the packet on the dump file */</span>
    <a class="code" href="group__wpcapfunc.html#g659439bf5aa3988b5a92d31990fbf437">pcap_dump</a>(dumpfile, header, pkt_data);
}
</pre></div><p>
As you can see, the structure of the program is very similar to the ones we have seen in the previous lessons. The differences are:<ul>
<li>a call to <a class="el" href="group__wpcapfunc.html#g9506c33d580fdb5e5c288dba0f8a085c">pcap_dump_open()</a> is issued once the interface is opened. This call opens a dump file and associates it with the interface.</li><li>the packets are written to this file with a <a class="el" href="group__wpcapfunc.html#g659439bf5aa3988b5a92d31990fbf437">pcap_dump()</a> from the packet_handler() callback. The parameters of <a class="el" href="group__wpcapfunc.html#g659439bf5aa3988b5a92d31990fbf437">pcap_dump()</a> are in 1-1 correspondence with the parameters of <a class="el" href="group__wpcapfunc.html#gc429cf4f27205111259ff7b02a82eeab">pcap_handler()</a>.</li></ul>
<p>
<b>Reading packets from a dump file</b><p>
Now that we have a dump file available, we can try to read its content. The following code opens a WinPcap/libpcap dump file and displays every packet contained in the file. The file is opened with <a class="el" href="group__wpcapfunc.html#g91078168a13de8848df2b7b83d1f5b69">pcap_open_offline()</a>, then the usual <a class="el" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop()</a> is used to sequence through the packets. As you can see, reading packets from an offline capture is nearly identical to receiving them from a physical interface.<p>
This example introduces another function: pcap_createsrcsrc(). This function is required to create a source string that begins with a marker used to tell WinPcap the type of the source, e.g. "rpcap://" if we are going to open an adapter, or "file://" if we are going to open a file. This step is not required when <a class="el" href="group__wpcapfunc.html#g98f36e62c95c6ad81eaa8b2bbeb8f16e">pcap_findalldevs_ex()</a> is used (the returned values already contain these strings). However, it is required in this example because the name of the file is read from the user input.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="preprocessor">#define LINE_LEN 16</span>
<span class="preprocessor"></span>
<span class="keywordtype">void</span> dispatcher_handler(u_char *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *, <span class="keyword">const</span> u_char *);

main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
<a class="code" href="group__wpcap__def.html#g4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *fp;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#gcd448353957d92c98fccc29e1fc8d927">PCAP_ERRBUF_SIZE</a>];
<span class="keywordtype">char</span> source[<a class="code" href="group__remote__struct.html#gcacb155b596f7511f714de129ae32c97">PCAP_BUF_SIZE</a>];

    <span class="keywordflow">if</span>(argc != 2){

        printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
        <span class="keywordflow">return</span> -1;

    }

    <span class="comment">/* Create the source string according to the new WinPcap syntax */</span>
    <span class="keywordflow">if</span> ( <a class="code" href="group__wpcapfunc.html#ga3111e10f930a9772a32a922b26948b0">pcap_createsrcstr</a>( source,         <span class="comment">// variable that will keep the source string</span>
                            <a class="code" href="group__remote__source__ID.html#g9188ad0fc0d12fc51d1e9f5e78bf9440">PCAP_SRC_FILE</a>,  <span class="comment">// we want to open a file</span>
                            NULL,           <span class="comment">// remote host</span>
                            NULL,           <span class="comment">// port on the remote host</span>
                            argv[1],        <span class="comment">// name of the file we want to open</span>
                            errbuf          <span class="comment">// error buffer</span>
                            ) != 0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError creating a source string\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Open the capture file */</span>
    <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791">pcap_open</a>(source,         <span class="comment">// name of the device</span>
                        65536,          <span class="comment">// portion of the packet to capture</span>
                                        <span class="comment">// 65536 guarantees that the whole packet will be captured on all the link layers</span>
                         <a class="code" href="group__remote__open__flags.html#g9134ce51a9a6a7d497c3dee5affdc3b9">PCAP_OPENFLAG_PROMISCUOUS</a>,     <span class="comment">// promiscuous mode</span>
                         1000,              <span class="comment">// read timeout</span>
                         NULL,              <span class="comment">// authentication on the remote machine</span>
                         errbuf         <span class="comment">// error buffer</span>
                         ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the file %s.\n"</span>, source);
        <span class="keywordflow">return</span> -1;
    }

    <span class="comment">// read and dispatch packets until EOF is reached</span>
    <a class="code" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop</a>(fp, 0, dispatcher_handler, NULL);

    <span class="keywordflow">return</span> 0;
}



<span class="keywordtype">void</span> dispatcher_handler(u_char *temp1, 
                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    u_int i=0;
    
    <span class="comment">/* print pkt timestamp and pkt len */</span>
    printf(<span class="stringliteral">"%ld:%ld (%ld)\n"</span>, header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_sec, header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#728f264db4f5cc304742565a2bcdbeea">len</a>);          
    
    <span class="comment">/* Print the packet */</span>
    <span class="keywordflow">for</span> (i=1; (i &lt; header-&gt;<a class="code" href="structpcap__pkthdr.html#ac5771ed2efd92508bb4fe650f2ce7d7">caplen</a> + 1 ) ; i++)
    {
        printf(<span class="stringliteral">"%.2x "</span>, pkt_data[i-1]);
        <span class="keywordflow">if</span> ( (i % LINE_LEN) == 0) printf(<span class="stringliteral">"\n"</span>);
    }
    
    printf(<span class="stringliteral">"\n\n"</span>);     
    
}
</pre></div><p>
The following example has the same purpose of the last one, but <a class="el" href="group__wpcapfunc.html#g439439c2eae61161dc1efb1e03a81133">pcap_next_ex()</a> is used instead of the <a class="el" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop()</a> callback method.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="preprocessor">#define LINE_LEN 16</span>
<span class="preprocessor"></span>
main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
<a class="code" href="group__wpcap__def.html#g4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *fp;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#gcd448353957d92c98fccc29e1fc8d927">PCAP_ERRBUF_SIZE</a>];
<span class="keywordtype">char</span> source[<a class="code" href="group__remote__struct.html#gcacb155b596f7511f714de129ae32c97">PCAP_BUF_SIZE</a>];
<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header;
<span class="keyword">const</span> u_char *pkt_data;
u_int i=0;
<span class="keywordtype">int</span> res;

    <span class="keywordflow">if</span>(argc != 2)
    {
        printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Create the source string according to the new WinPcap syntax */</span>
    <span class="keywordflow">if</span> ( <a class="code" href="group__wpcapfunc.html#ga3111e10f930a9772a32a922b26948b0">pcap_createsrcstr</a>( source,         <span class="comment">// variable that will keep the source string</span>
                            <a class="code" href="group__remote__source__ID.html#g9188ad0fc0d12fc51d1e9f5e78bf9440">PCAP_SRC_FILE</a>,  <span class="comment">// we want to open a file</span>
                            NULL,           <span class="comment">// remote host</span>
                            NULL,           <span class="comment">// port on the remote host</span>
                            argv[1],        <span class="comment">// name of the file we want to open</span>
                            errbuf          <span class="comment">// error buffer</span>
                            ) != 0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError creating a source string\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Open the capture file */</span>
    <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791">pcap_open</a>(source,         <span class="comment">// name of the device</span>
                        65536,          <span class="comment">// portion of the packet to capture</span>
                                        <span class="comment">// 65536 guarantees that the whole packet will be captured on all the link layers</span>
                         <a class="code" href="group__remote__open__flags.html#g9134ce51a9a6a7d497c3dee5affdc3b9">PCAP_OPENFLAG_PROMISCUOUS</a>,     <span class="comment">// promiscuous mode</span>
                         1000,              <span class="comment">// read timeout</span>
                         NULL,              <span class="comment">// authentication on the remote machine</span>
                         errbuf         <span class="comment">// error buffer</span>
                         ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the file %s.\n"</span>, source);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* Retrieve the packets from the file */</span>
    <span class="keywordflow">while</span>((res = <a class="code" href="group__wpcapfunc.html#g439439c2eae61161dc1efb1e03a81133">pcap_next_ex</a>( fp, &amp;header, &amp;pkt_data)) &gt;= 0)
    {
        <span class="comment">/* print pkt timestamp and pkt len */</span>
        printf(<span class="stringliteral">"%ld:%ld (%ld)\n"</span>, header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_sec, header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#728f264db4f5cc304742565a2bcdbeea">len</a>);          
        
        <span class="comment">/* Print the packet */</span>
        <span class="keywordflow">for</span> (i=1; (i &lt; header-&gt;<a class="code" href="structpcap__pkthdr.html#ac5771ed2efd92508bb4fe650f2ce7d7">caplen</a> + 1 ) ; i++)
        {
            printf(<span class="stringliteral">"%.2x "</span>, pkt_data[i-1]);
            <span class="keywordflow">if</span> ( (i % LINE_LEN) == 0) printf(<span class="stringliteral">"\n"</span>);
        }
        
        printf(<span class="stringliteral">"\n\n"</span>);     
    }
    
    
    <span class="keywordflow">if</span> (res == -1)
    {
        printf(<span class="stringliteral">"Error reading the packets: %s\n"</span>, <a class="code" href="group__wpcapfunc.html#g81305cb154e4497e95bbb9b708631a3a">pcap_geterr</a>(fp));
    }
    
    <span class="keywordflow">return</span> 0;
}

</pre></div><p>
<b>Writing packets to a dump file with pcap_live_dump</b><p>
<b>NOTE:</b> At the moment, due to some problems with the new kernel buffer, this feature has been disabled.<p>
Recent versions of WinPcap provide a further way to save network traffic to disk, the <a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> function. <a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> takes three parameters: a file name, the maximum size (in bytes) that this file is allowed to reach and the maximum amount of packets that the file is allowed to contain. Zero means no limit for both these values. Notice that the program can set a filter (with <a class="el" href="group__wpcapfunc.html#gf5f9cfe85dad0967ff607e5159b1ba61">pcap_setfilter()</a>, see the tutorial <a class="el" href="group__wpcap__tut5.html">Filtering the traffic</a>) before calling <a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> to define the subset of the traffic that will be saved.<p>
<a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> is non-blocking, therefore it starts the dump and returns immediately: The dump process goes on asynchronously until the maximum file size or the maximum amount of packets has been reached.<p>
The application can wait or check the end of the dump with <a class="el" href="group__wpcapfunc.html#gfe8a334f3a7ae2dc7f52e96523da39be">pcap_live_dump_ended()</a>. <b>Beware</b> that if the <em>sync</em> parameter is nonzero, this function will block your application forever if the limits are both 0.<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)</span>
<span class="comment"> * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)</span>
<span class="comment"> * All rights reserved.</span>
<span class="comment"> *</span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<span class="comment"> * modification, are permitted provided that the following conditions</span>
<span class="comment"> * are met:</span>
<span class="comment"> *</span>
<span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
<span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="comment"> * notice, this list of conditions and the following disclaimer in the</span>
<span class="comment"> * documentation and/or other materials provided with the distribution.</span>
<span class="comment"> * 3. Neither the name of the Politecnico di Torino, CACE Technologies </span>
<span class="comment"> * nor the names of its contributors may be used to endorse or promote </span>
<span class="comment"> * products derived from this software without specific prior written </span>
<span class="comment"> * permission.</span>
<span class="comment"> *</span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment"> *</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="preprocessor">#error At the moment the kernel dump feature is not supported in the driver</span>
<span class="preprocessor"></span>
main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
    
    <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs, *d;
    <a class="code" href="group__wpcap__def.html#g4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *fp;
    u_int inum, i=0;
    <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#gcd448353957d92c98fccc29e1fc8d927">PCAP_ERRBUF_SIZE</a>];

    printf(<span class="stringliteral">"kdump: saves the network traffic to file using WinPcap kernel-level dump faeature.\n"</span>);
    printf(<span class="stringliteral">"\t Usage: %s [adapter] | dump_file_name max_size max_packs\n"</span>, argv[0]);
    printf(<span class="stringliteral">"\t Where: max_size is the maximum size that the dump file will reach (0 means no limit)\n"</span>);
    printf(<span class="stringliteral">"\t Where: max_packs is the maximum number of packets that will be saved (0 means no limit)\n\n"</span>);


    <span class="keywordflow">if</span>(argc &lt; 5){

        <span class="comment">/* The user didn't provide a packet source: Retrieve the device list */</span>
        <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#g7b128eaeef627b408f6a6e2a2f5eb45d">pcap_findalldevs</a>(&amp;alldevs, errbuf) == -1)
        {
            fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
            exit(1);
        }
        
        <span class="comment">/* Print the list */</span>
        <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#81508e6e4e41ca4235c8d6b51913c536">next</a>)
        {
            printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#5ac083a645d964373f022d03df4849c8">name</a>);
            if (d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>)
                printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>);
            <span class="keywordflow">else</span>
                printf(<span class="stringliteral">" (No description available)\n"</span>);
        }
        
        <span class="keywordflow">if</span>(i==0)
        {
            printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
            <span class="keywordflow">return</span> -1;
        }
        
        printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
        scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
        
        <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
        {
            printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
            <span class="comment">/* Free the device list */</span>
            <span class="keywordflow">return</span> -1;
        }
        
        <span class="comment">/* Jump to the selected adapter */</span>
        <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#81508e6e4e41ca4235c8d6b51913c536">next</a>, i++);
        
        <span class="comment">/* Open the device */</span>
        <span class="keywordflow">if</span> ( (fp = <a class="code" href="group__wpcapfunc.html#gae6abe06e15c87b803f69773822beca8">pcap_open_live</a>(d-&gt;<a class="code" href="structpcap__if.html#5ac083a645d964373f022d03df4849c8">name</a>, 100, 1, 20, errbuf) ) == NULL)
        {
            fprintf(stderr,<span class="stringliteral">"\nError opening adapter\n"</span>);
            <span class="keywordflow">return</span> -1;
        }

        <span class="comment">/* Free the device list */</span>
        <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);

        <span class="comment">/* Start the dump */</span>
        <span class="keywordflow">if</span>(<a class="code" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump</a>(fp, argv[1], atoi(argv[2]), atoi(argv[3]))==-1){
            printf(<span class="stringliteral">"Unable to start the dump, %s\n"</span>, <a class="code" href="group__wpcapfunc.html#g81305cb154e4497e95bbb9b708631a3a">pcap_geterr</a>(fp));
            <span class="keywordflow">return</span> -1;
        }
    }
    <span class="keywordflow">else</span>{
        
        <span class="comment">/* Open the device */</span>
        <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#gae6abe06e15c87b803f69773822beca8">pcap_open_live</a>(argv[1], 100, 1, 20, errbuf) ) == NULL)
        {
            fprintf(stderr,<span class="stringliteral">"\nError opening adapter\n"</span>);
            <span class="keywordflow">return</span> -1;
        }

        <span class="comment">/* Start the dump */</span>
        <span class="keywordflow">if</span>(<a class="code" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump</a>(fp, argv[0], atoi(argv[1]), atoi(argv[2]))==-1){
            printf(<span class="stringliteral">"Unable to start the dump, %s\n"</span>, <a class="code" href="group__wpcapfunc.html#g81305cb154e4497e95bbb9b708631a3a">pcap_geterr</a>(fp));
            <span class="keywordflow">return</span> -1;
        }
    }

    <span class="comment">/* Wait until the dump finishes, i.e. when  max_size or max_packs is reached*/</span>
    <a class="code" href="group__wpcapfunc.html#gfe8a334f3a7ae2dc7f52e96523da39be">pcap_live_dump_ended</a>(fp, TRUE);
    
    <span class="comment">/* Close the adapter, so that the file is correctly flushed */</span>
    <a class="code" href="group__wpcapfunc.html#ga45a5e1a4ba9925bb3586dcbeec78560">pcap_close</a>(fp);

    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
The difference between <a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> and <a class="el" href="group__wpcapfunc.html#g659439bf5aa3988b5a92d31990fbf437">pcap_dump()</a>, apart from the possibility to set limits, is performance. <a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> exploits the ability of the WinPcap NPF driver (see <a class="el" href="group__NPF.html">NPF driver internals manual</a>) to write dumps from kernel level, minimizing the number of context switches and memory copies.<p>
Obviously, since this feature is currently not available on other operating systems, <a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> is WinPcap specific and is present only under Win32.<p>
<a class="el" href="group__wpcap__tut6.html">&lt;&lt;&lt; Previous</a> <a class="el" href="group__wpcap__tut8.html">Next &gt;&gt;&gt;</a> 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005-2007 
CACE Technologies. All rights reserved.</p>
