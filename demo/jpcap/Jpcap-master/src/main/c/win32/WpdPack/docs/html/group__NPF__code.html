<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>WinPcap: NPF functions</title>
<link href="style.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>NPF functions<br>
<small>
[<a class="el" href="group__NPF.html">NPF driver internals manual</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g6502d781bd20234a06710b92d540baba">DriverEntry</a> (IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The initialization routine of the driver.  <a href="#g6502d781bd20234a06710b92d540baba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PWCHAR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#gfc395636686df00f554efbd2010f73cb">getAdaptersList</a> (VOID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the list of the MACs available on the system.  <a href="#gfc395636686df00f554efbd2010f73cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PKEY_VALUE_PARTIAL_INFORMATION&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#gcf0e32b371eb9283e5cf1de0dfb15629">getTcpBindings</a> (VOID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the MACs that bind to TCP/IP.  <a href="#gcf0e32b371eb9283e5cf1de0dfb15629"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOLEAN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g8b4f23818c00c1186aa0bc59b57ff6c6">createDevice</a> (IN OUT PDRIVER_OBJECT adriverObjectP, IN PUNICODE_STRING amacNameP, NDIS_HANDLE aProtoHandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a device for a given MAC.  <a href="#g8b4f23818c00c1186aa0bc59b57ff6c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g82e557625e52fe4395bbe2e494fe8c4a">NPF_Open</a> (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens a new instance of the driver.  <a href="#g82e557625e52fe4395bbe2e494fe8c4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g155ae51be29c6d36f8109781b8f6e7b2">NPF_OpenAdapterComplete</a> (IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_STATUS Status, IN NDIS_STATUS OpenErrorStatus)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends the opening of an adapter.  <a href="#g155ae51be29c6d36f8109781b8f6e7b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#gfae94a0e7fda8de180cff6e596cc2803">NPF_Cleanup</a> (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes an instance of the driver.  <a href="#gfae94a0e7fda8de180cff6e596cc2803"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#gf8b70be389645c912cf09f1e9ea4b975">NPF_Close</a> (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g300118a9a6cc28c2c880f6bb39d86b53">NPF_CloseAdapterComplete</a> (IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_STATUS Status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends the closing of an adapter.  <a href="#g300118a9a6cc28c2c880f6bb39d86b53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NDIS_STATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g92f84ced372baf09f1c00a6b252a0564">NPF_tap</a> (IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_HANDLE MacReceiveContext, IN PVOID HeaderBuffer, IN UINT HeaderBufferSize, IN PVOID LookAheadBuffer, IN UINT LookaheadBufferSize, IN UINT PacketSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback invoked by NDIS when a packet arrives from the network.  <a href="#g92f84ced372baf09f1c00a6b252a0564"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g0c34f931d6718be202c7c62406f279fd">NPF_TransferDataComplete</a> (IN NDIS_HANDLE ProtocolBindingContext, IN PNDIS_PACKET Packet, IN NDIS_STATUS Status, IN UINT BytesTransferred)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends the transfer of a packet.  <a href="#g0c34f931d6718be202c7c62406f279fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#ge7863db01a628ed11324c49953195855">NPF_ReceiveComplete</a> (IN NDIS_HANDLE ProtocolBindingContext)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function that signals the end of a packet reception.  <a href="#ge7863db01a628ed11324c49953195855"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#gd8b208720b6e5149dabcd7fb058b16f7">NPF_IoControl</a> (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handles the IOCTL calls.  <a href="#gd8b208720b6e5149dabcd7fb058b16f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g4ff37c0fd3273f829a1f84b9ab40755b">NPF_RequestComplete</a> (IN NDIS_HANDLE ProtocolBindingContext, IN PNDIS_REQUEST pRequest, IN NDIS_STATUS Status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends an OID request.  <a href="#g4ff37c0fd3273f829a1f84b9ab40755b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g595338435296a4d1e15363ebfcb3a38c">NPF_Write</a> (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a raw packet to the network.  <a href="#g595338435296a4d1e15363ebfcb3a38c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">INT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g9a97dd25ae757da4bfed3723a4eb4bce">NPF_BufferedWrite</a> (IN PIRP Irp, IN PCHAR UserBuff, IN ULONG UserBuffSize, BOOLEAN sync)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a buffer of raw packets to the network.  <a href="#g9a97dd25ae757da4bfed3723a4eb4bce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g8861b474efcb6578c9fe2075ff3e6aef">NPF_WaitEndOfBufferedWrite</a> (<a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a> Open)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits the completion of all the sends performed by NPF_BufferedWrite.  <a href="#g8861b474efcb6578c9fe2075ff3e6aef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#ged126572458eed2dcd18d1824ac86601">NPF_SendComplete</a> (IN NDIS_HANDLE ProtocolBindingContext, IN PNDIS_PACKET pPacket, IN NDIS_STATUS Status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends a send operation.  <a href="#ged126572458eed2dcd18d1824ac86601"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g4e7934d9adb1826ed5e9112b9182f74a">NPF_ResetComplete</a> (IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_STATUS Status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends a reset of the adapter.  <a href="#g4e7934d9adb1826ed5e9112b9182f74a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g1a8cf4fdeed6e93fcf1f50da654402b7">NPF_Status</a> (IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_STATUS Status, IN PVOID StatusBuffer, IN UINT StatusBufferSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback for NDIS StatusHandler. Not used by NPF.  <a href="#g1a8cf4fdeed6e93fcf1f50da654402b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g70f97109adcd6de8b157534e5ecf2e56">NPF_StatusComplete</a> (IN NDIS_HANDLE ProtocolBindingContext)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback for NDIS StatusCompleteHandler. Not used by NPF.  <a href="#g70f97109adcd6de8b157534e5ecf2e56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g5eb5a8e754198d1bbc6572cbc9e59b9c">NPF_Unload</a> (IN PDRIVER_OBJECT DriverObject)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function called by the OS when NPF is unloaded.  <a href="#g5eb5a8e754198d1bbc6572cbc9e59b9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g827b1433b2d08cbac11b3844d721668f">NPF_Read</a> (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function that serves the user's reads.  <a href="#g827b1433b2d08cbac11b3844d721668f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g1a3ce25625792c74e5792b8fa86a489c">NPF_ReadRegistry</a> (IN PWSTR *MacDriverName, IN PWSTR *PacketDriverName, IN PUNICODE_STRING RegistryPath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the registry keys associated woth NPF if the driver is manually installed via the control panel.  <a href="#g1a3ce25625792c74e5792b8fa86a489c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g8831b54dcd5361e81ddf0d3165f1fb8f">NPF_QueryRegistryRoutine</a> (IN PWSTR ValueName, IN ULONG ValueType, IN PVOID ValueData, IN ULONG ValueLength, IN PVOID Context, IN PVOID EntryContext)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function used by <a class="el" href="group__NPF__code.html#g1a3ce25625792c74e5792b8fa86a489c">NPF_ReadRegistry()</a> to quesry the registry keys associated woth NPF if the driver is manually installed via the control panel.  <a href="#g8831b54dcd5361e81ddf0d3165f1fb8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g9a78f9937b2d7d00250f49dcaeb5bab0">NPF_BindAdapter</a> (OUT PNDIS_STATUS Status, IN NDIS_HANDLE BindContext, IN PNDIS_STRING DeviceName, IN PVOID SystemSpecific1, IN PVOID SystemSpecific2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback for NDIS BindAdapterHandler. Not used by NPF.  <a href="#g9a78f9937b2d7d00250f49dcaeb5bab0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g54d94e883ff4c580289eefaf0d1fc356">NPF_UnbindAdapter</a> (OUT PNDIS_STATUS Status, IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_HANDLE UnbindContext)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback for NDIS UnbindAdapterHandler.  <a href="#g54d94e883ff4c580289eefaf0d1fc356"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#ge3d1118c72b474fe214517a65afdfe09">NPF_OpenDumpFile</a> (<a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a> Open, PUNICODE_STRING fileName, BOOLEAN append)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates the file that will receive the packets when the driver is in dump mode.  <a href="#ge3d1118c72b474fe214517a65afdfe09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#geffce124cbc3e3ae09bd7a6d10367cbb">NPF_StartDump</a> (<a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a> Open)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts dump to file.  <a href="#geffce124cbc3e3ae09bd7a6d10367cbb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g1566082cef91cf79ba4a855e3f44ede9">NPF_DumpThread</a> (PVOID Open)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The dump thread.  <a href="#g1566082cef91cf79ba4a855e3f44ede9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#gfcdcf5a4d9bfb8fbdb179963d4c789bd">NPF_SaveCurrentBuffer</a> (<a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a> Open)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves the content of the packet buffer to the file associated with current instance.  <a href="#gfcdcf5a4d9bfb8fbdb179963d4c789bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g57b9ee7752f00c8858bda8ca060a033b">NPF_WriteDumpFile</a> (PFILE_OBJECT FileObject, PLARGE_INTEGER Offset, ULONG Length, PMDL Mdl, PIO_STATUS_BLOCK IoStatusBlock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a block of packets on the dump file.  <a href="#g57b9ee7752f00c8858bda8ca060a033b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#gc911742b9f71c12c77452614db14c4a1">NPF_CloseDumpFile</a> (<a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a> Open)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes the dump file associated with an instance of the driver.  <a href="#gc911742b9f71c12c77452614db14c4a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#gb282095d6b161cba67f29f5b59de06a6">NPF_CloseOpenInstance</a> (<a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a> pOpen)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOLEAN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g64dab96bfced5d22cc55a42fc6339833">NPF_StartUsingBinding</a> (IN <a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a> pOpen)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#gcd54077d4c2d9186486d3504523ba4f0">NPF_StopUsingBinding</a> (IN <a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a> pOpen)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g76d4e48415cea8e0e65ba93d7355b89f">NPF_CloseBinding</a> (IN <a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a> pOpen)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NTSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g8bad85679d2e8c57f7501052f9b07284">NPF_GetDeviceMTU</a> (IN <a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a> pOpen, IN PIRP pIrp, OUT PUINT pMtu)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#gdd6737f745e21b37b8613b489a96687d">GetBuffOccupation</a> (<a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a> Open)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the amount of bytes present in the packet buffer.  <a href="#gdd6737f745e21b37b8613b489a96687d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structJIT__BPF__Filter.html">JIT_BPF_Filter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#gb95019314e0cce415388272574f85ed7">BPF_jitter</a> (struct bpf_insn *fp, INT nins)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BPF jitter, builds an x86 function from a BPF program.  <a href="#gb95019314e0cce415388272574f85ed7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__NPF.html#ge8a6f0f4b1137f0f68bd759ad4edca32">BPF_filter_function</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#gac4070271462268d182b0dbdbfcb1a88">BPFtoX86</a> (struct bpf_insn *ins, UINT nins, INT *mem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translates a set of BPF instructions in a set of x86 ones.  <a href="#gac4070271462268d182b0dbdbfcb1a88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NPF__code.html#g8d441782c2295f2f71d32727dd3f28a0">BPF_Destroy_JIT_Filter</a> (<a class="el" href="structJIT__BPF__Filter.html">JIT_BPF_Filter</a> *Filter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a filtering function that was previously created by <a class="el" href="group__NPF__code.html#gb95019314e0cce415388272574f85ed7">BPF_jitter()</a>.  <a href="#g8d441782c2295f2f71d32727dd3f28a0"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g8d441782c2295f2f71d32727dd3f28a0"></a><!-- doxytag: member="jitter.h::BPF_Destroy_JIT_Filter" ref="g8d441782c2295f2f71d32727dd3f28a0" args="(JIT_BPF_Filter *Filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BPF_Destroy_JIT_Filter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJIT__BPF__Filter.html">JIT_BPF_Filter</a> *&nbsp;</td>
          <td class="paramname"> <em>Filter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes a filtering function that was previously created by <a class="el" href="group__NPF__code.html#gb95019314e0cce415388272574f85ed7">BPF_jitter()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Filter</em>&nbsp;</td><td>The filter to destroy.</td></tr>
  </table>
</dl>
This function frees the variuos buffers (code, memory, etc.) associated with a filtering function. 
</div>
</div><p>
<a class="anchor" name="gb95019314e0cce415388272574f85ed7"></a><!-- doxytag: member="jitter.h::BPF_jitter" ref="gb95019314e0cce415388272574f85ed7" args="(struct bpf_insn *fp, INT nins)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJIT__BPF__Filter.html">JIT_BPF_Filter</a>* BPF_jitter           </td>
          <td>(</td>
          <td class="paramtype">struct bpf_insn *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&nbsp;</td>
          <td class="paramname"> <em>nins</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
BPF jitter, builds an x86 function from a BPF program. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>The BPF pseudo-assembly filter that will be translated into x86 code. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nins</em>&nbsp;</td><td>Number of instructions of the input filter. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="structJIT__BPF__Filter.html">JIT_BPF_Filter</a> structure containing the x86 filtering binary.</dd></dl>
BPF_jitter allocates the buffers for the new native filter and then translates the program pointed by fp calling <a class="el" href="group__NPF__code.html#gac4070271462268d182b0dbdbfcb1a88">BPFtoX86()</a>. 
</div>
</div><p>
<a class="anchor" name="gac4070271462268d182b0dbdbfcb1a88"></a><!-- doxytag: member="jitter.h::BPFtoX86" ref="gac4070271462268d182b0dbdbfcb1a88" args="(struct bpf_insn *ins, UINT nins, INT *mem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NPF.html#ge8a6f0f4b1137f0f68bd759ad4edca32">BPF_filter_function</a> BPFtoX86           </td>
          <td>(</td>
          <td class="paramtype">struct bpf_insn *&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&nbsp;</td>
          <td class="paramname"> <em>nins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT *&nbsp;</td>
          <td class="paramname"> <em>mem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translates a set of BPF instructions in a set of x86 ones. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ins</em>&nbsp;</td><td>Pointer to the BPF instructions that will be translated into x86 code. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nins</em>&nbsp;</td><td>Number of instructions to translate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mem</em>&nbsp;</td><td>Memory used by the x86 function to emulate the RAM of the BPF pseudo processor. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The x86 filtering function.</dd></dl>
This function does the hard work for the JIT compilation. It takes a group of BPF pseudo instructions and through the instruction macros defined in <a class="el" href="jitter_8h.html">jitter.h</a> it is able to create an function directly executable by NPF. 
</div>
</div><p>
<a class="anchor" name="g8b4f23818c00c1186aa0bc59b57ff6c6"></a><!-- doxytag: member="Packet.h::createDevice" ref="g8b4f23818c00c1186aa0bc59b57ff6c6" args="(IN OUT PDRIVER_OBJECT adriverObjectP, IN PUNICODE_STRING amacNameP, NDIS_HANDLE aProtoHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN createDevice           </td>
          <td>(</td>
          <td class="paramtype">IN OUT PDRIVER_OBJECT&nbsp;</td>
          <td class="paramname"> <em>adriverObjectP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PUNICODE_STRING&nbsp;</td>
          <td class="paramname"> <em>amacNameP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>aProtoHandle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a device for a given MAC. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>adriverObjectP</em>&nbsp;</td><td>The driver object that will be associated with the device, i.e. the one of NPF. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>amacNameP</em>&nbsp;</td><td>The name of the network interface that the device will point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aProtoHandle</em>&nbsp;</td><td>NDIS protocol handle of NPF. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>If the function succeeds, the return value is nonzero.</dd></dl>
NPF creates a device for every valid network adapter. The new device points to the NPF driver, but contains information about the original device. In this way, when the user opens the new device, NPF will be able to determine the correct adapter to use. 
</div>
</div><p>
<a class="anchor" name="g6502d781bd20234a06710b92d540baba"></a><!-- doxytag: member="Packet.h::DriverEntry" ref="g6502d781bd20234a06710b92d540baba" args="(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS DriverEntry           </td>
          <td>(</td>
          <td class="paramtype">IN PDRIVER_OBJECT&nbsp;</td>
          <td class="paramname"> <em>DriverObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PUNICODE_STRING&nbsp;</td>
          <td class="paramname"> <em>RegistryPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The initialization routine of the driver. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DriverObject</em>&nbsp;</td><td>The driver object of NPF created by the system. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegistryPath</em>&nbsp;</td><td>The registry path containing the keys related to the driver. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A string containing a list of network adapters.</dd></dl>
DriverEntry is a mandatory function in a device driver. Like the main() of a user level program, it is called by the system when the driver is loaded in memory and started. Its purpose is to initialize the driver, performing all the allocations and the setup. In particular, DriverEntry registers all the driver's I/O callbacks, creates the devices, defines NPF as a protocol inside NDIS. 
</div>
</div><p>
<a class="anchor" name="gfc395636686df00f554efbd2010f73cb"></a><!-- doxytag: member="Packet.h::getAdaptersList" ref="gfc395636686df00f554efbd2010f73cb" args="(VOID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PWCHAR getAdaptersList           </td>
          <td>(</td>
          <td class="paramtype">VOID&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the list of the MACs available on the system. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A string containing a list of network adapters.</dd></dl>
The list of adapters is retrieved from the SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318} registry key. NPF tries to create its bindings from this list. In this way it is possible to be loaded and unloaded dynamically without passing from the control panel. 
</div>
</div><p>
<a class="anchor" name="gdd6737f745e21b37b8613b489a96687d"></a><!-- doxytag: member="Packet.h::GetBuffOccupation" ref="gdd6737f745e21b37b8613b489a96687d" args="(POPEN_INSTANCE Open)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT GetBuffOccupation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>&nbsp;</td>
          <td class="paramname"> <em>Open</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the amount of bytes present in the packet buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Open</em>&nbsp;</td><td>The NPF instance that closes the file. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gcf0e32b371eb9283e5cf1de0dfb15629"></a><!-- doxytag: member="Packet.h::getTcpBindings" ref="gcf0e32b371eb9283e5cf1de0dfb15629" args="(VOID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PKEY_VALUE_PARTIAL_INFORMATION getTcpBindings           </td>
          <td>(</td>
          <td class="paramtype">VOID&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the MACs that bind to TCP/IP. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the registry key containing the list of adapters on which TCP/IP is bound.</dd></dl>
If <a class="el" href="group__NPF__code.html#gfc395636686df00f554efbd2010f73cb">getAdaptersList()</a> fails, NPF tries to obtain the TCP/IP bindings through this function. 
</div>
</div><p>
<a class="anchor" name="g9a78f9937b2d7d00250f49dcaeb5bab0"></a><!-- doxytag: member="Packet.h::NPF_BindAdapter" ref="g9a78f9937b2d7d00250f49dcaeb5bab0" args="(OUT PNDIS_STATUS Status, IN NDIS_HANDLE BindContext, IN PNDIS_STRING DeviceName, IN PVOID SystemSpecific1, IN PVOID SystemSpecific2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_BindAdapter           </td>
          <td>(</td>
          <td class="paramtype">OUT PNDIS_STATUS&nbsp;</td>
          <td class="paramname"> <em>Status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>BindContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PNDIS_STRING&nbsp;</td>
          <td class="paramname"> <em>DeviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PVOID&nbsp;</td>
          <td class="paramname"> <em>SystemSpecific1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PVOID&nbsp;</td>
          <td class="paramname"> <em>SystemSpecific2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback for NDIS BindAdapterHandler. Not used by NPF. 
<p>
Function called by NDIS when a new adapter is installed on the machine With Plug and Play. 
</div>
</div><p>
<a class="anchor" name="g9a97dd25ae757da4bfed3723a4eb4bce"></a><!-- doxytag: member="Packet.h::NPF_BufferedWrite" ref="g9a97dd25ae757da4bfed3723a4eb4bce" args="(IN PIRP Irp, IN PCHAR UserBuff, IN ULONG UserBuffSize, BOOLEAN sync)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT NPF_BufferedWrite           </td>
          <td>(</td>
          <td class="paramtype">IN PIRP&nbsp;</td>
          <td class="paramname"> <em>Irp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PCHAR&nbsp;</td>
          <td class="paramname"> <em>UserBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN ULONG&nbsp;</td>
          <td class="paramname"> <em>UserBuffSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN&nbsp;</td>
          <td class="paramname"> <em>sync</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a buffer of raw packets to the network. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Irp</em>&nbsp;</td><td>Pointer to the IRP containing the user request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UserBuff</em>&nbsp;</td><td>Pointer to the buffer containing the packets to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UserBuffSize</em>&nbsp;</td><td>Size of the buffer with the packets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sync</em>&nbsp;</td><td>If set to TRUE, the packets are transmitted respecting their timestamps. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The amount of bytes actually sent. If the return value is smaller than the Size parameter, an error occurred during the send. The error can be caused by an adapter problem or by an inconsistent/bogus user buffer.</dd></dl>
This function is called by the OS in consequence of a BIOCSENDPACKETSNOSYNC or a BIOCSENDPACKETSSYNC IOCTL. The buffer received as input parameter contains an arbitrary number of packets, each of which preceded by a <a class="el" href="structsf__pkthdr.html">sf_pkthdr</a> structure. <a class="el" href="group__NPF__code.html#g9a97dd25ae757da4bfed3723a4eb4bce">NPF_BufferedWrite()</a> scans the buffer and sends every packet via the NdisSend() function. When Sync is set to TRUE, the packets are synchronized with the KeQueryPerformanceCounter() function. This requires a remarkable amount of CPU, but allows to respect the timestamps associated with packets with a precision of some microseconds (depending on the precision of the performance counter of the machine). If Sync is false, the timestamps are ignored and the packets are sent as fat as possible. 
</div>
</div><p>
<a class="anchor" name="gfae94a0e7fda8de180cff6e596cc2803"></a><!-- doxytag: member="Packet.h::NPF_Cleanup" ref="gfae94a0e7fda8de180cff6e596cc2803" args="(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_Cleanup           </td>
          <td>(</td>
          <td class="paramtype">IN PDEVICE_OBJECT&nbsp;</td>
          <td class="paramname"> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PIRP&nbsp;</td>
          <td class="paramname"> <em>Irp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closes an instance of the driver. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceObject</em>&nbsp;</td><td>Pointer to the device object utilized by the user. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Irp</em>&nbsp;</td><td>Pointer to the IRP containing the user request. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. See ntstatus.h in the DDK.</dd></dl>
This function is called when a running instance of the driver is closed by the user with a CloseHandle(). It stops the capture/monitoring/dump process, deallocates the memory and the objects associated with the instance and closing the files. The network adapter is then closed with a call to NdisCloseAdapter. 
</div>
</div><p>
<a class="anchor" name="gf8b70be389645c912cf09f1e9ea4b975"></a><!-- doxytag: member="Packet.h::NPF_Close" ref="gf8b70be389645c912cf09f1e9ea4b975" args="(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_Close           </td>
          <td>(</td>
          <td class="paramtype">IN PDEVICE_OBJECT&nbsp;</td>
          <td class="paramname"> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PIRP&nbsp;</td>
          <td class="paramname"> <em>Irp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g300118a9a6cc28c2c880f6bb39d86b53"></a><!-- doxytag: member="Packet.h::NPF_CloseAdapterComplete" ref="g300118a9a6cc28c2c880f6bb39d86b53" args="(IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_STATUS Status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_CloseAdapterComplete           </td>
          <td>(</td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>ProtocolBindingContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN NDIS_STATUS&nbsp;</td>
          <td class="paramname"> <em>Status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ends the closing of an adapter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ProtocolBindingContext</em>&nbsp;</td><td>Context of the function. Contains a pointer to the OPEN_INSTANCE structure associated with the current instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Status</em>&nbsp;</td><td>Status of the close operation performed by NDIS.</td></tr>
  </table>
</dl>
Callback function associated with the NdisCloseAdapter() NDIS function. It is invoked by NDIS when the NIC driver has finished a close operation that was previously started by <a class="el" href="group__NPF__code.html#gf8b70be389645c912cf09f1e9ea4b975">NPF_Close()</a>. 
</div>
</div><p>
<a class="anchor" name="g76d4e48415cea8e0e65ba93d7355b89f"></a><!-- doxytag: member="Packet.h::NPF_CloseBinding" ref="g76d4e48415cea8e0e65ba93d7355b89f" args="(IN POPEN_INSTANCE pOpen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_CloseBinding           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>&nbsp;</td>
          <td class="paramname"> <em>pOpen</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="gc911742b9f71c12c77452614db14c4a1"></a><!-- doxytag: member="Packet.h::NPF_CloseDumpFile" ref="gc911742b9f71c12c77452614db14c4a1" args="(POPEN_INSTANCE Open)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_CloseDumpFile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>&nbsp;</td>
          <td class="paramname"> <em>Open</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closes the dump file associated with an instance of the driver. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Open</em>&nbsp;</td><td>The NPF instance that closes the file. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. See ntstatus.h in the DDK. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb282095d6b161cba67f29f5b59de06a6"></a><!-- doxytag: member="Packet.h::NPF_CloseOpenInstance" ref="gb282095d6b161cba67f29f5b59de06a6" args="(POPEN_INSTANCE pOpen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_CloseOpenInstance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>&nbsp;</td>
          <td class="paramname"> <em>pOpen</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g1566082cef91cf79ba4a855e3f44ede9"></a><!-- doxytag: member="Packet.h::NPF_DumpThread" ref="g1566082cef91cf79ba4a855e3f44ede9" args="(PVOID Open)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_DumpThread           </td>
          <td>(</td>
          <td class="paramtype">PVOID&nbsp;</td>
          <td class="paramname"> <em>Open</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The dump thread. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Open</em>&nbsp;</td><td>The NPF instance that creates the thread.</td></tr>
  </table>
</dl>
This function moves the content of the NPF kernel buffer to file. It runs in the user context, so at lower priority than the TAP. 
</div>
</div><p>
<a class="anchor" name="g8bad85679d2e8c57f7501052f9b07284"></a><!-- doxytag: member="Packet.h::NPF_GetDeviceMTU" ref="g8bad85679d2e8c57f7501052f9b07284" args="(IN POPEN_INSTANCE pOpen, IN PIRP pIrp, OUT PUINT pMtu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_GetDeviceMTU           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>&nbsp;</td>
          <td class="paramname"> <em>pOpen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PIRP&nbsp;</td>
          <td class="paramname"> <em>pIrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT PUINT&nbsp;</td>
          <td class="paramname"> <em>pMtu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="gd8b208720b6e5149dabcd7fb058b16f7"></a><!-- doxytag: member="Packet.h::NPF_IoControl" ref="gd8b208720b6e5149dabcd7fb058b16f7" args="(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_IoControl           </td>
          <td>(</td>
          <td class="paramtype">IN PDEVICE_OBJECT&nbsp;</td>
          <td class="paramname"> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PIRP&nbsp;</td>
          <td class="paramname"> <em>Irp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handles the IOCTL calls. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceObject</em>&nbsp;</td><td>Pointer to the device object utilized by the user. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Irp</em>&nbsp;</td><td>Pointer to the IRP containing the user request. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. See ntstatus.h in the DDK.</dd></dl>
Once the packet capture driver is opened it can be configured from user-level applications with IOCTL commands using the DeviceIoControl() system call. NPF_IoControl receives and serves all the IOCTL calls directed to NPF. The following commands are recognized:<ul>
<li><a class="el" href="group__NPF__include.html#g71817d3a52bf0ec819934a5f688a172c">BIOCSETBUFFERSIZE</a></li><li><a class="el" href="group__NPF__include.html#gf85f500f68404076ac60ffe6e08818da">BIOCSETF</a></li><li><a class="el" href="group__NPF__include.html#g8ae8be8faa281644d8be1cda38b826bd">BIOCGSTATS</a></li><li><a class="el" href="group__NPF__include.html#g327015c2b2e347212b571d1fa3aa2f54">BIOCSRTIMEOUT</a></li><li><a class="el" href="group__NPF__include.html#gd1012b82859d09864d246b1fa99d48d6">BIOCSMODE</a></li><li><a class="el" href="group__NPF__include.html#g1436997ce2947bbbe22b5400254438a1">BIOCSWRITEREP</a></li><li><a class="el" href="group__NPF__include.html#ga827e3441e3f84abc7df5e30fcee96d1">BIOCSMINTOCOPY</a></li><li><a class="el" href="group__NPF__include.html#gbf9a4779fd5281607510edc8b5d766dd">BIOCSETOID</a></li><li><a class="el" href="group__NPF__include.html#g5a0ab3231052ff323817e288dab2f127">BIOCQUERYOID</a></li><li><a class="el" href="group__NPF__include.html#gc8b51f8abae12f57a2ea8e8e4c0cd53c">BIOCSETDUMPFILENAME</a></li><li><a class="el" href="group__NPF__include.html#gdd9e03a96d297a33d7cee4d750c34eff">BIOCGEVNAME</a></li><li><a class="el" href="group__NPF__include.html#gb4d41e91e460bb101ef8ddb622a8e010">BIOCSENDPACKETSSYNC</a></li><li><a class="el" href="group__NPF__include.html#gc50830dc08762383dcb203a66e5c853d">BIOCSENDPACKETSNOSYNC</a> </li></ul>

</div>
</div><p>
<a class="anchor" name="g82e557625e52fe4395bbe2e494fe8c4a"></a><!-- doxytag: member="Packet.h::NPF_Open" ref="g82e557625e52fe4395bbe2e494fe8c4a" args="(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_Open           </td>
          <td>(</td>
          <td class="paramtype">IN PDEVICE_OBJECT&nbsp;</td>
          <td class="paramname"> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PIRP&nbsp;</td>
          <td class="paramname"> <em>Irp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens a new instance of the driver. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceObject</em>&nbsp;</td><td>Pointer to the device object utilized by the user. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Irp</em>&nbsp;</td><td>Pointer to the IRP containing the user request. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. See ntstatus.h in the DDK.</dd></dl>
This function is called by the OS when a new instance of the driver is opened, i.e. when a user application performs a CreateFile on a device created by NPF. NPF_Open allocates and initializes variables, objects and buffers needed by the new instance, fills the OPEN_INSTANCE structure associated with it and opens the adapter with a call to NdisOpenAdapter. 
</div>
</div><p>
<a class="anchor" name="g155ae51be29c6d36f8109781b8f6e7b2"></a><!-- doxytag: member="Packet.h::NPF_OpenAdapterComplete" ref="g155ae51be29c6d36f8109781b8f6e7b2" args="(IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_STATUS Status, IN NDIS_STATUS OpenErrorStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_OpenAdapterComplete           </td>
          <td>(</td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>ProtocolBindingContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN NDIS_STATUS&nbsp;</td>
          <td class="paramname"> <em>Status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN NDIS_STATUS&nbsp;</td>
          <td class="paramname"> <em>OpenErrorStatus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ends the opening of an adapter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ProtocolBindingContext</em>&nbsp;</td><td>Context of the function. Contains a pointer to the OPEN_INSTANCE structure associated with the current instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Status</em>&nbsp;</td><td>Status of the opening operation performed by NDIS. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OpenErrorStatus</em>&nbsp;</td><td>not used by NPF.</td></tr>
  </table>
</dl>
Callback function associated with the NdisOpenAdapter() NDIS function. It is invoked by NDIS when the NIC driver has finished an open operation that was previously started by <a class="el" href="group__NPF__code.html#g82e557625e52fe4395bbe2e494fe8c4a">NPF_Open()</a>. 
</div>
</div><p>
<a class="anchor" name="ge3d1118c72b474fe214517a65afdfe09"></a><!-- doxytag: member="Packet.h::NPF_OpenDumpFile" ref="ge3d1118c72b474fe214517a65afdfe09" args="(POPEN_INSTANCE Open, PUNICODE_STRING fileName, BOOLEAN append)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_OpenDumpFile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>&nbsp;</td>
          <td class="paramname"> <em>Open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUNICODE_STRING&nbsp;</td>
          <td class="paramname"> <em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN&nbsp;</td>
          <td class="paramname"> <em>append</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates the file that will receive the packets when the driver is in dump mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Open</em>&nbsp;</td><td>The NPF instance that opens the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fileName</em>&nbsp;</td><td>Pointer to a UNICODE string containing the name of the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>append</em>&nbsp;</td><td>Boolean value that specifies if the data must be appended to the file. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. See ntstatus.h in the DDK. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8831b54dcd5361e81ddf0d3165f1fb8f"></a><!-- doxytag: member="Packet.h::NPF_QueryRegistryRoutine" ref="g8831b54dcd5361e81ddf0d3165f1fb8f" args="(IN PWSTR ValueName, IN ULONG ValueType, IN PVOID ValueData, IN ULONG ValueLength, IN PVOID Context, IN PVOID EntryContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_QueryRegistryRoutine           </td>
          <td>(</td>
          <td class="paramtype">IN PWSTR&nbsp;</td>
          <td class="paramname"> <em>ValueName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN ULONG&nbsp;</td>
          <td class="paramname"> <em>ValueType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PVOID&nbsp;</td>
          <td class="paramname"> <em>ValueData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN ULONG&nbsp;</td>
          <td class="paramname"> <em>ValueLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PVOID&nbsp;</td>
          <td class="paramname"> <em>Context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PVOID&nbsp;</td>
          <td class="paramname"> <em>EntryContext</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function used by <a class="el" href="group__NPF__code.html#g1a3ce25625792c74e5792b8fa86a489c">NPF_ReadRegistry()</a> to quesry the registry keys associated woth NPF if the driver is manually installed via the control panel. 
<p>
Normally not used in recent versions of NPF. 
</div>
</div><p>
<a class="anchor" name="g827b1433b2d08cbac11b3844d721668f"></a><!-- doxytag: member="Packet.h::NPF_Read" ref="g827b1433b2d08cbac11b3844d721668f" args="(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_Read           </td>
          <td>(</td>
          <td class="paramtype">IN PDEVICE_OBJECT&nbsp;</td>
          <td class="paramname"> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PIRP&nbsp;</td>
          <td class="paramname"> <em>Irp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function that serves the user's reads. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceObject</em>&nbsp;</td><td>Pointer to the device used by the user. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Irp</em>&nbsp;</td><td>Pointer to the IRP containing the user request. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. See ntstatus.h in the DDK.</dd></dl>
This function is called by the OS in consequence of user ReadFile() call. It moves the data present in the kernel buffer to the user buffer associated with Irp. First of all, NPF_Read checks the amount of data in kernel buffer associated with current NPF instance.<ul>
<li>If the instance is in capture mode and the buffer contains more than <a class="el" href="struct__OPEN__INSTANCE.html#263f7d6f5db5625541d275380685f0b1">OPEN_INSTANCE::MinToCopy</a> bytes, NPF_Read moves the data in the user buffer and returns immediatly. In this way, the read performed by the user is not blocking.</li><li>If the buffer contains less than MinToCopy bytes, the application's request isn't satisfied immediately, but it's blocked until at least MinToCopy bytes arrive from the net or the timeout on this read expires. The timeout is kept in the <a class="el" href="struct__OPEN__INSTANCE.html#a6709070de8443c026e3b86913942c2b">OPEN_INSTANCE::TimeOut</a> field.</li><li>If the instance is in statistical mode or in dump mode, the application's request is blocked until the timeout kept in <a class="el" href="struct__OPEN__INSTANCE.html#a6709070de8443c026e3b86913942c2b">OPEN_INSTANCE::TimeOut</a> expires. </li></ul>

</div>
</div><p>
<a class="anchor" name="g1a3ce25625792c74e5792b8fa86a489c"></a><!-- doxytag: member="Packet.h::NPF_ReadRegistry" ref="g1a3ce25625792c74e5792b8fa86a489c" args="(IN PWSTR *MacDriverName, IN PWSTR *PacketDriverName, IN PUNICODE_STRING RegistryPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_ReadRegistry           </td>
          <td>(</td>
          <td class="paramtype">IN PWSTR *&nbsp;</td>
          <td class="paramname"> <em>MacDriverName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PWSTR *&nbsp;</td>
          <td class="paramname"> <em>PacketDriverName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PUNICODE_STRING&nbsp;</td>
          <td class="paramname"> <em>RegistryPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the registry keys associated woth NPF if the driver is manually installed via the control panel. 
<p>
Normally not used in recent versions of NPF. 
</div>
</div><p>
<a class="anchor" name="ge7863db01a628ed11324c49953195855"></a><!-- doxytag: member="Packet.h::NPF_ReceiveComplete" ref="ge7863db01a628ed11324c49953195855" args="(IN NDIS_HANDLE ProtocolBindingContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_ReceiveComplete           </td>
          <td>(</td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>ProtocolBindingContext</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback function that signals the end of a packet reception. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ProtocolBindingContext</em>&nbsp;</td><td>Context of the function. Contains a pointer to the OPEN_INSTANCE structure associated with the current instance.</td></tr>
  </table>
</dl>
does nothing in NPF 
</div>
</div><p>
<a class="anchor" name="g4ff37c0fd3273f829a1f84b9ab40755b"></a><!-- doxytag: member="Packet.h::NPF_RequestComplete" ref="g4ff37c0fd3273f829a1f84b9ab40755b" args="(IN NDIS_HANDLE ProtocolBindingContext, IN PNDIS_REQUEST pRequest, IN NDIS_STATUS Status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_RequestComplete           </td>
          <td>(</td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>ProtocolBindingContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PNDIS_REQUEST&nbsp;</td>
          <td class="paramname"> <em>pRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN NDIS_STATUS&nbsp;</td>
          <td class="paramname"> <em>Status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ends an OID request. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ProtocolBindingContext</em>&nbsp;</td><td>Context of the function. Contains a pointer to the OPEN_INSTANCE structure associated with the current instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRequest</em>&nbsp;</td><td>Pointer to the completed OID request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Status</em>&nbsp;</td><td>Status of the operation.</td></tr>
  </table>
</dl>
Callback function associated with the NdisRequest() NDIS function. It is invoked by NDIS when the NIC driver has finished an OID request operation that was previously started by <a class="el" href="group__NPF__code.html#gd8b208720b6e5149dabcd7fb058b16f7">NPF_IoControl()</a>. 
</div>
</div><p>
<a class="anchor" name="g4e7934d9adb1826ed5e9112b9182f74a"></a><!-- doxytag: member="Packet.h::NPF_ResetComplete" ref="g4e7934d9adb1826ed5e9112b9182f74a" args="(IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_STATUS Status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_ResetComplete           </td>
          <td>(</td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>ProtocolBindingContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN NDIS_STATUS&nbsp;</td>
          <td class="paramname"> <em>Status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ends a reset of the adapter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ProtocolBindingContext</em>&nbsp;</td><td>Context of the function. Contains a pointer to the OPEN_INSTANCE structure associated with the current instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Status</em>&nbsp;</td><td>Status of the operation.</td></tr>
  </table>
</dl>
Callback function associated with the NdisReset() NDIS function. It is invoked by NDIS when the NIC driver has finished an OID request operation that was previously started by <a class="el" href="group__NPF__code.html#gd8b208720b6e5149dabcd7fb058b16f7">NPF_IoControl()</a>, in an IOCTL_PROTOCOL_RESET command. 
</div>
</div><p>
<a class="anchor" name="gfcdcf5a4d9bfb8fbdb179963d4c789bd"></a><!-- doxytag: member="Packet.h::NPF_SaveCurrentBuffer" ref="gfcdcf5a4d9bfb8fbdb179963d4c789bd" args="(POPEN_INSTANCE Open)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_SaveCurrentBuffer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>&nbsp;</td>
          <td class="paramname"> <em>Open</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the content of the packet buffer to the file associated with current instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Open</em>&nbsp;</td><td>The NPF instance that creates the thread.</td></tr>
  </table>
</dl>
Used by <a class="el" href="group__NPF__code.html#g1566082cef91cf79ba4a855e3f44ede9">NPF_DumpThread()</a> and <a class="el" href="group__NPF__code.html#gc911742b9f71c12c77452614db14c4a1">NPF_CloseDumpFile()</a>. 
</div>
</div><p>
<a class="anchor" name="ged126572458eed2dcd18d1824ac86601"></a><!-- doxytag: member="Packet.h::NPF_SendComplete" ref="ged126572458eed2dcd18d1824ac86601" args="(IN NDIS_HANDLE ProtocolBindingContext, IN PNDIS_PACKET pPacket, IN NDIS_STATUS Status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_SendComplete           </td>
          <td>(</td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>ProtocolBindingContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PNDIS_PACKET&nbsp;</td>
          <td class="paramname"> <em>pPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN NDIS_STATUS&nbsp;</td>
          <td class="paramname"> <em>Status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ends a send operation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ProtocolBindingContext</em>&nbsp;</td><td>Context of the function. Contains a pointer to the OPEN_INSTANCE structure associated with the current instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pPacket</em>&nbsp;</td><td>Pointer to the NDIS PACKET structure used by <a class="el" href="group__NPF__code.html#g595338435296a4d1e15363ebfcb3a38c">NPF_Write()</a> to send the packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Status</em>&nbsp;</td><td>Status of the operation.</td></tr>
  </table>
</dl>
Callback function associated with the NdisSend() NDIS function. It is invoked by NDIS when the NIC driver has finished an OID request operation that was previously started by <a class="el" href="group__NPF__code.html#g595338435296a4d1e15363ebfcb3a38c">NPF_Write()</a>. 
</div>
</div><p>
<a class="anchor" name="geffce124cbc3e3ae09bd7a6d10367cbb"></a><!-- doxytag: member="Packet.h::NPF_StartDump" ref="geffce124cbc3e3ae09bd7a6d10367cbb" args="(POPEN_INSTANCE Open)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_StartDump           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>&nbsp;</td>
          <td class="paramname"> <em>Open</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts dump to file. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Open</em>&nbsp;</td><td>The NPF instance that opens the file. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. See ntstatus.h in the DDK.</dd></dl>
This function performs two operations. First, it writes the libpcap header at the beginning of the file. Second, it starts the thread that asynchronously dumps the network data to the file. 
</div>
</div><p>
<a class="anchor" name="g64dab96bfced5d22cc55a42fc6339833"></a><!-- doxytag: member="Packet.h::NPF_StartUsingBinding" ref="g64dab96bfced5d22cc55a42fc6339833" args="(IN POPEN_INSTANCE pOpen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN NPF_StartUsingBinding           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>&nbsp;</td>
          <td class="paramname"> <em>pOpen</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g1a8cf4fdeed6e93fcf1f50da654402b7"></a><!-- doxytag: member="Packet.h::NPF_Status" ref="g1a8cf4fdeed6e93fcf1f50da654402b7" args="(IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_STATUS Status, IN PVOID StatusBuffer, IN UINT StatusBufferSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_Status           </td>
          <td>(</td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>ProtocolBindingContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN NDIS_STATUS&nbsp;</td>
          <td class="paramname"> <em>Status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PVOID&nbsp;</td>
          <td class="paramname"> <em>StatusBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN UINT&nbsp;</td>
          <td class="paramname"> <em>StatusBufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback for NDIS StatusHandler. Not used by NPF. 
<p>

</div>
</div><p>
<a class="anchor" name="g70f97109adcd6de8b157534e5ecf2e56"></a><!-- doxytag: member="Packet.h::NPF_StatusComplete" ref="g70f97109adcd6de8b157534e5ecf2e56" args="(IN NDIS_HANDLE ProtocolBindingContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_StatusComplete           </td>
          <td>(</td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>ProtocolBindingContext</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback for NDIS StatusCompleteHandler. Not used by NPF. 
<p>

</div>
</div><p>
<a class="anchor" name="gcd54077d4c2d9186486d3504523ba4f0"></a><!-- doxytag: member="Packet.h::NPF_StopUsingBinding" ref="gcd54077d4c2d9186486d3504523ba4f0" args="(IN POPEN_INSTANCE pOpen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_StopUsingBinding           </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>&nbsp;</td>
          <td class="paramname"> <em>pOpen</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g92f84ced372baf09f1c00a6b252a0564"></a><!-- doxytag: member="Packet.h::NPF_tap" ref="g92f84ced372baf09f1c00a6b252a0564" args="(IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_HANDLE MacReceiveContext, IN PVOID HeaderBuffer, IN UINT HeaderBufferSize, IN PVOID LookAheadBuffer, IN UINT LookaheadBufferSize, IN UINT PacketSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDIS_STATUS NPF_tap           </td>
          <td>(</td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>ProtocolBindingContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>MacReceiveContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PVOID&nbsp;</td>
          <td class="paramname"> <em>HeaderBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN UINT&nbsp;</td>
          <td class="paramname"> <em>HeaderBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PVOID&nbsp;</td>
          <td class="paramname"> <em>LookAheadBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN UINT&nbsp;</td>
          <td class="paramname"> <em>LookaheadBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN UINT&nbsp;</td>
          <td class="paramname"> <em>PacketSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback invoked by NDIS when a packet arrives from the network. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ProtocolBindingContext</em>&nbsp;</td><td>Context of the function. Points to a OPEN_INSTANCE structure that identifies the NPF instance to which the packets are destined. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MacReceiveContext</em>&nbsp;</td><td>Handle that identifies the underlying NIC driver that generated the request. This value must be used when the packet is transferred from the NIC driver with NdisTransferData(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HeaderBuffer</em>&nbsp;</td><td>Pointer to the buffer in the NIC driver memory that contains the header of the packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HeaderBufferSize</em>&nbsp;</td><td>Size in bytes of the header. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LookAheadBuffer</em>&nbsp;</td><td>Pointer to the buffer in the NIC driver's memory that contains the incoming packet's data <b>available to NPF</b>. This value does not necessarily coincide with the actual size of the packet, since only a portion can be available at this time. The remaining portion can be obtained with the NdisTransferData() NDIS function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LookaheadBufferSize</em>&nbsp;</td><td>Size in bytes of the lookahead buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PacketSize</em>&nbsp;</td><td>Total size of the incoming packet, excluded the header. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. See ntstatus.h in the DDK.</dd></dl>
<a class="el" href="group__NPF__code.html#g92f84ced372baf09f1c00a6b252a0564">NPF_tap()</a> is called by the underlying NIC for every incoming packet. It is the most important and one of the most complex functions of NPF: it executes the filter, runs the statistical engine (if the instance is in statistical mode), gathers the timestamp, moves the packet in the buffer. <a class="el" href="group__NPF__code.html#g92f84ced372baf09f1c00a6b252a0564">NPF_tap()</a> is the only function, along with the filtering ones, that is executed for every incoming packet, therefore it is carefully optimized. 
</div>
</div><p>
<a class="anchor" name="g0c34f931d6718be202c7c62406f279fd"></a><!-- doxytag: member="Packet.h::NPF_TransferDataComplete" ref="g0c34f931d6718be202c7c62406f279fd" args="(IN NDIS_HANDLE ProtocolBindingContext, IN PNDIS_PACKET Packet, IN NDIS_STATUS Status, IN UINT BytesTransferred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_TransferDataComplete           </td>
          <td>(</td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>ProtocolBindingContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PNDIS_PACKET&nbsp;</td>
          <td class="paramname"> <em>Packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN NDIS_STATUS&nbsp;</td>
          <td class="paramname"> <em>Status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN UINT&nbsp;</td>
          <td class="paramname"> <em>BytesTransferred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ends the transfer of a packet. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ProtocolBindingContext</em>&nbsp;</td><td>Context of the function. Contains a pointer to the OPEN_INSTANCE structure associated with the current instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Packet</em>&nbsp;</td><td>Pointer to the NDIS_PACKET structure that received the packet data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Status</em>&nbsp;</td><td>Status of the transfer operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesTransferred</em>&nbsp;</td><td>Amount of bytes transferred.</td></tr>
  </table>
</dl>
Callback function associated with the NdisTransferData() NDIS function. It is invoked by NDIS when the NIC driver has finished the transfer of a packet from the NIC driver memory to the NPF circular buffer. 
</div>
</div><p>
<a class="anchor" name="g54d94e883ff4c580289eefaf0d1fc356"></a><!-- doxytag: member="Packet.h::NPF_UnbindAdapter" ref="g54d94e883ff4c580289eefaf0d1fc356" args="(OUT PNDIS_STATUS Status, IN NDIS_HANDLE ProtocolBindingContext, IN NDIS_HANDLE UnbindContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_UnbindAdapter           </td>
          <td>(</td>
          <td class="paramtype">OUT PNDIS_STATUS&nbsp;</td>
          <td class="paramname"> <em>Status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>ProtocolBindingContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN NDIS_HANDLE&nbsp;</td>
          <td class="paramname"> <em>UnbindContext</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback for NDIS UnbindAdapterHandler. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Status</em>&nbsp;</td><td>out variable filled by NPF_UnbindAdapter with the status of the unbind operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ProtocolBindingContext</em>&nbsp;</td><td>Context of the function. Contains a pointer to the OPEN_INSTANCE structure associated with current instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnbindContext</em>&nbsp;</td><td>Specifies a handle, supplied by NDIS, that NPF can use to complete the opration.</td></tr>
  </table>
</dl>
Function called by NDIS when a new adapter is removed from the machine without shutting it down. NPF_UnbindAdapter closes the adapter calling NdisCloseAdapter() and frees the memory and the structures associated with it. It also releases the waiting user-level app and closes the dump thread if the instance is in dump mode. 
</div>
</div><p>
<a class="anchor" name="g5eb5a8e754198d1bbc6572cbc9e59b9c"></a><!-- doxytag: member="Packet.h::NPF_Unload" ref="g5eb5a8e754198d1bbc6572cbc9e59b9c" args="(IN PDRIVER_OBJECT DriverObject)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_Unload           </td>
          <td>(</td>
          <td class="paramtype">IN PDRIVER_OBJECT&nbsp;</td>
          <td class="paramname"> <em>DriverObject</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function called by the OS when NPF is unloaded. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DriverObject</em>&nbsp;</td><td>The driver object of NPF created by the system.</td></tr>
  </table>
</dl>
This is the last function executed when the driver is unloaded from the system. It frees global resources, delete the devices and deregisters the protocol. The driver can be unloaded by the user stopping the NPF service (from control panel or with a console 'net stop npf'). 
</div>
</div><p>
<a class="anchor" name="g8861b474efcb6578c9fe2075ff3e6aef"></a><!-- doxytag: member="Packet.h::NPF_WaitEndOfBufferedWrite" ref="g8861b474efcb6578c9fe2075ff3e6aef" args="(POPEN_INSTANCE Open)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_WaitEndOfBufferedWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__OPEN__INSTANCE.html">POPEN_INSTANCE</a>&nbsp;</td>
          <td class="paramname"> <em>Open</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits the completion of all the sends performed by NPF_BufferedWrite. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Open</em>&nbsp;</td><td>Pointer to open context structure</td></tr>
  </table>
</dl>
Used by NPF_BufferedWrite to wait the completion of all the sends before returning the control to the user. 
</div>
</div><p>
<a class="anchor" name="g595338435296a4d1e15363ebfcb3a38c"></a><!-- doxytag: member="Packet.h::NPF_Write" ref="g595338435296a4d1e15363ebfcb3a38c" args="(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTSTATUS NPF_Write           </td>
          <td>(</td>
          <td class="paramtype">IN PDEVICE_OBJECT&nbsp;</td>
          <td class="paramname"> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN PIRP&nbsp;</td>
          <td class="paramname"> <em>Irp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a raw packet to the network. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceObject</em>&nbsp;</td><td>Pointer to the device object on which the user wrote the packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Irp</em>&nbsp;</td><td>Pointer to the IRP containing the user request. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. See ntstatus.h in the DDK.</dd></dl>
This function is called by the OS in consequence of user WriteFile() call, with the data of the packet that must be sent on the net. The data is contained in the buffer associated with Irp, NPF_Write takes it and delivers it to the NIC driver via the NdisSend() function. The Nwrites field of the OPEN_INSTANCE structure associated with Irp indicates the number of copies of the packet that will be sent: more than one copy of the packet can be sent for performance reasons. 
</div>
</div><p>
<a class="anchor" name="g57b9ee7752f00c8858bda8ca060a033b"></a><!-- doxytag: member="Packet.h::NPF_WriteDumpFile" ref="g57b9ee7752f00c8858bda8ca060a033b" args="(PFILE_OBJECT FileObject, PLARGE_INTEGER Offset, ULONG Length, PMDL Mdl, PIO_STATUS_BLOCK IoStatusBlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID NPF_WriteDumpFile           </td>
          <td>(</td>
          <td class="paramtype">PFILE_OBJECT&nbsp;</td>
          <td class="paramname"> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PLARGE_INTEGER&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PMDL&nbsp;</td>
          <td class="paramname"> <em>Mdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PIO_STATUS_BLOCK&nbsp;</td>
          <td class="paramname"> <em>IoStatusBlock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a block of packets on the dump file. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>FileObject</em>&nbsp;</td><td>The file object that will receive the packets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>The offset in the file where the packets will be put. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>The amount of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mdl</em>&nbsp;</td><td>MDL mapping the memory buffer that will be written to disk. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IoStatusBlock</em>&nbsp;</td><td>Used by the function to return the status of the operation. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. See ntstatus.h in the DDK.</dd></dl>
NPF_WriteDumpFile addresses directly the file system, creating a custom IRP and using it to send a portion of the NPF circular buffer to disk. This function is used by <a class="el" href="group__NPF__code.html#g1566082cef91cf79ba4a855e3f44ede9">NPF_DumpThread()</a>. 
</div>
</div><p>

<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005-2007 
CACE Technologies. All rights reserved.</p>
